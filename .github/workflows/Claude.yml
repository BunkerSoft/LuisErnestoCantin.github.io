name: Claude AI Assistant

on:
  issues:
    types: [opened, labeled, assigned]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, synchronize]
  pull_request_review_comment:
    types: [created]

jobs:
  claude-issue-response:
    if: |
      github.event_name == 'issues' && (
        contains(github.event.issue.labels.*.name, 'claude') ||
        contains(github.event.issue.labels.*.name, 'ai') ||
        contains(github.event.issue.body, '@claude')
      )

    runs-on: ubuntu-latest

    permissions:
      issues: write
      contents: read

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @octokit/rest

      # FIX #5: Pre-crear labels necesarios para evitar error 422
      - name: Ensure required labels exist
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh label create "claude-analyzed"   --color "0075ca" --description "Analizado por Claude AI" --force
          gh label create "claude-generated"  --color "1d76db" --description "Generado por Claude AI"  --force
          gh label create "needs-review"      --color "e4e669" --description "Requiere revisi√≥n humana" --force
          gh label create "performance"       --color "f9d0c4" --description "Relacionado con rendimiento" --force
          gh label create "seo"               --color "bfd4f2" --description "Relacionado con SEO"        --force
          gh label create "accessibility"     --color "d4c5f9" --description "Accesibilidad"              --force

      - name: Claude analyzes issue
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          ISSUE_AUTHOR: ${{ github.event.issue.user.login }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          node << 'ENDJS'
          const { Octokit } = require('@octokit/rest');
          const https = require('https');

          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

          // FIX #2: Usar Buffer para calcular Content-Length en bytes (no chars),
          // evitando desajuste con caracteres UTF-8 multi-byte (tildes, √±, etc.)
          function callClaude(prompt) {
            return new Promise((resolve, reject) => {
              const payload = {
                // FIX #1: Model string correcto (claude-sonnet-4-5-20250929 es v√°lido)
                model: "claude-sonnet-4-5-20250929",
                max_tokens: 4000,
                messages: [{ role: "user", content: prompt }]
              };
              const dataBuffer = Buffer.from(JSON.stringify(payload), 'utf8');

              const options = {
                hostname: 'api.anthropic.com',
                port: 443,
                path: '/v1/messages',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': process.env.ANTHROPIC_API_KEY,
                  'anthropic-version': '2023-06-01',
                  'Content-Length': dataBuffer.byteLength  // FIX #2: byteLength correcto
                }
              };

              const req = https.request(options, (res) => {
                let body = '';
                res.on('data', (chunk) => { body += chunk; });
                res.on('end', () => {
                  try {
                    const response = JSON.parse(body);
                    if (response.content && response.content[0]) {
                      resolve(response.content[0].text);
                    } else if (response.error) {
                      reject(new Error(response.error.message || 'API Error'));
                    } else {
                      reject(new Error('Invalid response: ' + body));
                    }
                  } catch (err) { reject(err); }
                });
              });
              req.on('error', reject);
              req.write(dataBuffer);  // FIX #2: escribir el Buffer, no el string
              req.end();
            });
          }

          async function main() {
            const issueNumber = parseInt(process.env.ISSUE_NUMBER);
            const issueTitle  = process.env.ISSUE_TITLE;
            const issueBody   = process.env.ISSUE_BODY || '';
            const issueAuthor = process.env.ISSUE_AUTHOR;

            console.log('Claude procesando Issue #' + issueNumber);

            try {
              const prompt =
                "Eres Claude, asistente AI del repo BunkerSoft/LuisErnestoCantin.github.io\n\n" +
                "Portfolio en GitHub Pages (HTML5, CSS3, JS vanilla)\n\n" +
                "Issue #" + issueNumber + "\n" +
                "Autor: @" + issueAuthor + "\n" +
                "T√≠tulo: " + issueTitle + "\n\n" +
                "Descripci√≥n:\n" + issueBody + "\n\n" +
                "Restricciones: GitHub Pages, sin frameworks, responsive\n\n" +
                "Tareas:\n" +
                "1. Analiza viabilidad\n" +
                "2. Plan paso a paso\n" +
                "3. C√≥digo espec√≠fico\n" +
                "4. Archivos a modificar\n" +
                "5. Estimaci√≥n\n\n" +
                "Responde en Markdown con: Resumen, Viabilidad, Objetivos, Plan, Validaci√≥n, Estimaci√≥n";

              const response = await callClaude(prompt);

              await octokit.issues.createComment({
                owner: process.env.REPO_OWNER,
                repo: process.env.REPO_NAME,
                issue_number: issueNumber,
                body: response
              });

              const labels   = ['claude-analyzed'];
              const combined = (issueTitle + ' ' + issueBody).toLowerCase();

              if (combined.includes('performance'))  labels.push('performance');
              if (combined.includes('seo'))          labels.push('seo');
              if (combined.includes('accessibility')) labels.push('accessibility');
              if (combined.includes('bug'))          labels.push('bug');

              await octokit.issues.addLabels({
                owner: process.env.REPO_OWNER,
                repo: process.env.REPO_NAME,
                issue_number: issueNumber,
                labels: labels
              });

              console.log('Completado');

            } catch (error) {
              console.error('Error:', error.message);
              await octokit.issues.createComment({
                owner: process.env.REPO_OWNER,
                repo: process.env.REPO_NAME,
                issue_number: issueNumber,
                body: "‚ö†Ô∏è Error al procesar con Claude: " + error.message
              });
              process.exit(1);
            }
          }

          main();
          ENDJS

  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  claude-implementation:
    if: |
      github.event_name == 'issue_comment' &&
      contains(github.event.comment.body, '/implement') &&
      contains(github.event.issue.labels.*.name, 'claude-analyzed')

    runs-on: ubuntu-latest

    permissions:
      contents: write
      pull-requests: write
      issues: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Configure Git
        run: |
          git config --global user.name "Claude AI Bot"
          git config --global user.email "claude@bunkersoft.dev"

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @octokit/rest

      # FIX #5: Garantizar labels antes de crear el PR
      - name: Ensure required labels exist
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          gh label create "claude-generated" --color "1d76db" --description "Generado por Claude AI"  --force
          gh label create "needs-review"     --color "e4e669" --description "Requiere revisi√≥n humana" --force

      - name: Notify start
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          COMMENT_AUTHOR: ${{ github.event.comment.user.login }}
        run: |
          gh issue comment "$ISSUE_NUMBER" --body "ü§ñ Implementaci√≥n iniciada por @$COMMENT_AUTHOR"

      - name: Generate implementation
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          ISSUE_BODY: ${{ github.event.issue.body }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
          # FIX #3: BRANCH_NAME expuesta como env var para que el heredoc la vea
          BRANCH_NAME: claude/issue-${{ github.event.issue.number }}
        run: |
          git checkout -b "$BRANCH_NAME"

          node << 'ENDJS'
          const { Octokit } = require('@octokit/rest');
          const https  = require('https');
          const fs     = require('fs');
          const { execSync } = require('child_process');

          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

          // FIX #2: Buffer para Content-Length correcto con UTF-8
          function callClaude(prompt, maxTokens = 8000) {
            return new Promise((resolve, reject) => {
              const payload = {
                model: "claude-sonnet-4-5-20250929",
                max_tokens: maxTokens,
                messages: [{ role: "user", content: prompt }]
              };
              const dataBuffer = Buffer.from(JSON.stringify(payload), 'utf8');

              const options = {
                hostname: 'api.anthropic.com',
                port: 443,
                path: '/v1/messages',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': process.env.ANTHROPIC_API_KEY,
                  'anthropic-version': '2023-06-01',
                  'Content-Length': dataBuffer.byteLength
                }
              };

              const req = https.request(options, (res) => {
                let body = '';
                res.on('data', (chunk) => { body += chunk; });
                res.on('end', () => {
                  try {
                    const response = JSON.parse(body);
                    if (response.content && response.content[0]) {
                      resolve(response.content[0].text);
                    } else if (response.error) {
                      reject(new Error(response.error.message || 'API Error'));
                    } else {
                      reject(new Error('Invalid response: ' + body));
                    }
                  } catch (err) { reject(err); }
                });
              });
              req.on('error', reject);
              req.write(dataBuffer);
              req.end();
            });
          }

          async function main() {
            const issueNumber = parseInt(process.env.ISSUE_NUMBER);
            const issueTitle  = process.env.ISSUE_TITLE;
            const issueBody   = process.env.ISSUE_BODY || '';

            console.log('Generando c√≥digo para Issue #' + issueNumber + '...');

            try {
              const files     = {};
              const fileNames = ['index.html', 'style.css', 'script.js', 'README.md'];

              for (const file of fileNames) {
                if (fs.existsSync(file)) {
                  files[file] = fs.readFileSync(file, 'utf8');
                }
              }

              const filesText = Object.entries(files)
                .map(([name, content]) => name + ":\n" + content.substring(0, 2000))
                .join('\n\n---\n\n');

              // FIX #6: Pedir JSON delimitado con ```json``` para parsing robusto
              const prompt =
                "Implementa la soluci√≥n para el Issue #" + issueNumber + ": " + issueTitle + "\n\n" +
                issueBody + "\n\n" +
                "Archivos actuales del proyecto:\n" + filesText + "\n\n" +
                "IMPORTANTE: Responde √öNICAMENTE con un bloque ```json``` que contenga exactamente:\n" +
                "```json\n" +
                "{\n" +
                '  "files": { "filename": "contenido completo del archivo modificado" },\n' +
                '  "new_files": { "filename": "contenido de archivos nuevos si se requieren" },\n' +
                '  "commit_message": "feat: descripci√≥n concisa del cambio",\n' +
                '  "pr_body": "Descripci√≥n detallada del PR en Markdown"\n' +
                "}\n" +
                "```\n" +
                "No incluyas texto fuera del bloque JSON.";

              const response = await callClaude(prompt);

              // FIX #6: Parsing robusto usando delimitador ```json```
              const jsonMatch = response.match(/```json\s*([\s\S]*?)\s*```/);
              if (!jsonMatch) {
                // Fallback: intentar extraer JSON raw si Claude no respet√≥ el formato
                const rawMatch = response.match(/\{[\s\S]*\}/);
                if (!rawMatch) throw new Error('No se encontr√≥ JSON v√°lido en la respuesta de Claude');
                console.warn('ADVERTENCIA: Claude no us√≥ delimitadores ```json```, usando fallback.');
              }

              const jsonStr = jsonMatch ? jsonMatch[1] : response.match(/\{[\s\S]*\}/)[0];
              const result  = JSON.parse(jsonStr);

              for (const [filename, content] of Object.entries(result.files || {})) {
                fs.writeFileSync(filename, content, 'utf8');
                execSync('git add ' + JSON.stringify(filename));
                console.log('Modificado: ' + filename);
              }

              for (const [filename, content] of Object.entries(result.new_files || {})) {
                // Crear directorios intermedios si hacen falta
                const dir = require('path').dirname(filename);
                if (dir !== '.') fs.mkdirSync(dir, { recursive: true });
                fs.writeFileSync(filename, content, 'utf8');
                execSync('git add ' + JSON.stringify(filename));
                console.log('Creado: ' + filename);
              }

              // Guardar metadata para el step de commit
              fs.writeFileSync('claude-metadata.json', JSON.stringify(result), 'utf8');
              console.log('Generaci√≥n completada.');

            } catch (error) {
              console.error('Error en generaci√≥n:', error.message);
              throw error;
            }
          }

          main();
          ENDJS

      - name: Commit and push
        env:
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          BRANCH_NAME: claude/issue-${{ github.event.issue.number }}
        run: |
          if [ -f claude-metadata.json ]; then
            COMMIT_MSG=$(node -e "
              const meta = JSON.parse(require('fs').readFileSync('claude-metadata.json','utf8'));
              console.log(meta.commit_message || 'feat: implement issue #${{ github.event.issue.number }}');
            ")
          else
            COMMIT_MSG="feat: implement issue #$ISSUE_NUMBER"
          fi

          git add -A
          git commit -m "$COMMIT_MSG" || echo "Sin cambios para commitear"
          git push origin "$BRANCH_NAME"

      - name: Create PR
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
          ISSUE_TITLE: ${{ github.event.issue.title }}
          BRANCH_NAME: claude/issue-${{ github.event.issue.number }}
        run: |
          # Leer pr_body de metadata si existe, sino usar mensaje por defecto
          if [ -f claude-metadata.json ]; then
            PR_BODY=$(node -e "
              const meta = JSON.parse(require('fs').readFileSync('claude-metadata.json','utf8'));
              console.log(meta.pr_body || 'Implementaci√≥n autom√°tica por Claude AI');
            ")
          else
            PR_BODY="Implementaci√≥n autom√°tica por Claude AI"
          fi

          gh pr create \
            --title "Fix #$ISSUE_NUMBER: $ISSUE_TITLE" \
            --body "Closes #$ISSUE_NUMBER

$PR_BODY" \
            --base main \
            --head "$BRANCH_NAME" \
            --label "claude-generated,needs-review"

          PR_URL=$(gh pr view "$BRANCH_NAME" --json url -q .url)
          gh issue comment "$ISSUE_NUMBER" --body "‚úÖ PR creado autom√°ticamente: $PR_URL"

  # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
  claude-pr-review:
    if: |
      github.event_name == 'pull_request' && (
        contains(github.event.pull_request.body, '@claude') ||
        contains(github.event.pull_request.labels.*.name, 'claude-review')
      )

    runs-on: ubuntu-latest

    permissions:
      pull-requests: write
      contents: read

    steps:
      - name: Checkout PR
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.head.sha }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install dependencies
        run: npm install @octokit/rest

      - name: Claude reviews PR
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          ANTHROPIC_API_KEY: ${{ secrets.ANTHROPIC_API_KEY }}
          PR_NUMBER: ${{ github.event.pull_request.number }}
          PR_TITLE: ${{ github.event.pull_request.title }}
          PR_BODY: ${{ github.event.pull_request.body }}
          PR_AUTHOR: ${{ github.event.pull_request.user.login }}
          REPO_OWNER: ${{ github.repository_owner }}
          REPO_NAME: ${{ github.event.repository.name }}
        run: |
          node << 'ENDJS'
          const { Octokit } = require('@octokit/rest');
          const https = require('https');

          const octokit = new Octokit({ auth: process.env.GITHUB_TOKEN });

          // FIX #2: Buffer para Content-Length correcto
          function callClaude(prompt) {
            return new Promise((resolve, reject) => {
              const payload = {
                model: "claude-sonnet-4-5-20250929",
                max_tokens: 4000,
                messages: [{ role: "user", content: prompt }]
              };
              const dataBuffer = Buffer.from(JSON.stringify(payload), 'utf8');

              const options = {
                hostname: 'api.anthropic.com',
                port: 443,
                path: '/v1/messages',
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'x-api-key': process.env.ANTHROPIC_API_KEY,
                  'anthropic-version': '2023-06-01',
                  'Content-Length': dataBuffer.byteLength
                }
              };

              const req = https.request(options, (res) => {
                let body = '';
                res.on('data', (chunk) => { body += chunk; });
                res.on('end', () => {
                  try {
                    const response = JSON.parse(body);
                    if (response.content && response.content[0]) {
                      resolve(response.content[0].text);
                    } else if (response.error) {
                      reject(new Error(response.error.message || 'API Error'));
                    } else {
                      reject(new Error('Invalid response: ' + body));
                    }
                  } catch (err) { reject(err); }
                });
              });
              req.on('error', reject);
              req.write(dataBuffer);
              req.end();
            });
          }

          async function main() {
            const prNumber = parseInt(process.env.PR_NUMBER);
            const prTitle  = process.env.PR_TITLE;
            const prBody   = process.env.PR_BODY || '';
            const prAuthor = process.env.PR_AUTHOR;

            console.log('Revisando PR #' + prNumber);

            try {
              const filesRes = await octokit.pulls.listFiles({
                owner: process.env.REPO_OWNER,
                repo:  process.env.REPO_NAME,
                pull_number: prNumber
              });

              const diffs = filesRes.data
                .map(f => f.filename + ': +' + f.additions + ' -' + f.deletions)
                .join('\n');

              const prompt =
                "Revisa el PR #" + prNumber + ": " + prTitle + "\n" +
                "Autor: @" + prAuthor + "\n" +
                "Descripci√≥n: " + prBody + "\n\n" +
                "Archivos modificados:\n" + diffs + "\n\n" +
                "Analiza: calidad de c√≥digo, performance, SEO, accesibilidad, seguridad.\n" +
                "Responde en Markdown con: Resumen Ejecutivo, Rating por categor√≠a (1-10), " +
                "Problemas encontrados, Sugerencias de mejora, y Recomendaci√≥n final: " +
                "APPROVE / COMMENT / REQUEST_CHANGES";

              const review = await callClaude(prompt);

              // Determinar el evento del review
              let event = 'COMMENT';
              if (review.includes('APPROVE') && !review.includes('REQUEST_CHANGES')) {
                event = 'APPROVE';
              } else if (review.includes('REQUEST_CHANGES')) {
                event = 'REQUEST_CHANGES';
              }

              await octokit.pulls.createReview({
                owner: process.env.REPO_OWNER,
                repo:  process.env.REPO_NAME,
                pull_number: prNumber,
                body:  review,
                event: event
              });

              console.log('Review publicado: ' + event);

            } catch (error) {
              console.error('Error en PR review:', error.message);
              throw error;
            }
          }

          main();
          ENDJS
